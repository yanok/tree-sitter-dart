// Automatically generated from ANTLR grammar.
// common bits
const epsilon = () => "";
const anythingBut = (s) => {
  if (s.length === 0) return repeat(/./);
  if (s.length === 1) return repeat(new RegExp("[^" + s + "]"));
  return repeat(
      choice(
        new RegExp("[^"+s[0]+"]"),
        seq(s[0], somethingBut(s.slice(1)))));
}
const somethingBut = (s) => {
  if (s.length === 0) return repeat1(/./);
  if (s.length === 1) return repeat1(new RegExp("[^" + s + "]"));
  return repeat1(
      choice(
        new RegExp("[^"+s[0]+"]"),
        seq(s[0], somethingBut(s.slice(1)))));
}
// inline tokens (fragments)
const LETTER = () => /[a-zA-Z]/;
const DIGIT = () => /[0-9]/;
const EXPONENT = () => seq(/[eE]/, optional(/[+-]/), repeat1(DIGIT()));
const HEX_DIGIT = () => choice(/[abcdef]/, /[ABCDEF]/, DIGIT());
const SIMPLE_STRING_INTERPOLATION = () => seq("$", IDENTIFIER_NO_DOLLAR());
const ESCAPE_SEQUENCE = () => choice("\\n", "\\r", "\\b", "\\t", "\\v", seq("\\x", HEX_DIGIT(), HEX_DIGIT()), seq("\\u", HEX_DIGIT(), HEX_DIGIT(), HEX_DIGIT(), HEX_DIGIT()), seq("\\u{", HEX_DIGIT_SEQUENCE(), "}"));
const HEX_DIGIT_SEQUENCE = () => seq(HEX_DIGIT(), optional(HEX_DIGIT()), optional(HEX_DIGIT()), optional(HEX_DIGIT()), optional(HEX_DIGIT()), optional(HEX_DIGIT()));
const STRING_CONTENT_COMMON = () => choice(/[^\\'"$\r\n]/, ESCAPE_SEQUENCE(), seq("\\", /[^nrbtvxu\r\n]/), SIMPLE_STRING_INTERPOLATION());
const STRING_CONTENT_SQ = () => choice(STRING_CONTENT_COMMON(), "\"");
const STRING_CONTENT_DQ = () => choice(STRING_CONTENT_COMMON(), "'");
const QUOTES_SQ = () => choice(epsilon(), "'", "''");
const STRING_CONTENT_TSQ = () => seq(QUOTES_SQ(), choice(STRING_CONTENT_COMMON(), "\"", "\r", "\n", "\\\r", "\\\n"));
const QUOTES_DQ = () => choice(epsilon(), "\"", "\"\"");
const STRING_CONTENT_TDQ = () => seq(QUOTES_DQ(), choice(STRING_CONTENT_COMMON(), "'", "\r", "\n", "\\\r", "\\\n"));
const IDENTIFIER_START_NO_DOLLAR = () => choice(LETTER(), "_");
const IDENTIFIER_PART_NO_DOLLAR = () => choice(IDENTIFIER_START_NO_DOLLAR(), DIGIT());
const IDENTIFIER_NO_DOLLAR = () => seq(IDENTIFIER_START_NO_DOLLAR(), repeat(IDENTIFIER_PART_NO_DOLLAR()));
const IDENTIFIER_START = () => choice(IDENTIFIER_START_NO_DOLLAR(), "$");
const IDENTIFIER_PART = () => choice(IDENTIFIER_START(), DIGIT());
const NEWLINE = () => choice("\r", "\n", "\r\n")

// inlined rules
const libraryDefinition = $ => seq(optional($.FEFF), optional($.SCRIPT_TAG), optional($.libraryName), repeat($.importOrExport), repeat($.partDirective), repeat(seq(metadata($), $.topLevelDefinition)));
const classModifiers = $ => choice($.SEALED, seq(optional($.ABSTRACT), optional(choice($.BASE, $.INTERFACE, $.FINAL))));
const metadata = $ => repeat(seq("@", $.metadatum));
const cascadeSectionTail = $ => choice($.cascadeAssignment, seq(repeat($.selector), optional(seq($.assignableSelector, $.cascadeAssignment))));
const statements = $ => repeat($.statement)
module.exports = grammar({
name: "dart",
  
word: $ => $.IDENTIFIER,
    

// things that were skip()ed in ANTLR
extras: $ => [
$._SINGLE_LINE_COMMENT, $._MULTI_LINE_COMMENT, $._WS
],
rules: {
// Parser rules
startSymbol: $ => choice(libraryDefinition($), $.partDeclaration),
topLevelDefinition: $ => choice($.classDeclaration, $.mixinDeclaration, $.extensionTypeDeclaration, $.extensionDeclaration, $.enumType, $.typeAlias, seq($.EXTERNAL, $.functionSignature, ";"), seq($.EXTERNAL, $.getterSignature, ";"), seq($.EXTERNAL, $.setterSignature, ";"), seq($.EXTERNAL, $.finalVarOrType, $.identifierList, ";"), seq($.getterSignature, $.functionBody), seq($.setterSignature, $.functionBody), seq($.functionSignature, $.functionBody), seq(choice($.FINAL, $.CONST), optional($.type), $.staticFinalDeclarationList, ";"), seq($.LATE, $.FINAL, optional($.type), $.initializedIdentifierList, ";"), seq(optional($.LATE), $.varOrType, $.identifier, optional(seq("=", $.expression)), repeat(seq(",", $.initializedIdentifier)), ";")),
declaredIdentifier: $ => seq(optional($.COVARIANT), $.finalConstVarOrType, $.identifier),
finalConstVarOrType: $ => choice(seq(optional($.LATE), $.FINAL, optional($.type)), seq($.CONST, optional($.type)), seq(optional($.LATE), $.varOrType)),
finalVarOrType: $ => choice(seq($.FINAL, optional($.type)), $.varOrType),
varOrType: $ => choice($.VAR, $.type),
initializedIdentifier: $ => seq($.identifier, optional(seq("=", $.expression))),
initializedIdentifierList: $ => seq($.initializedIdentifier, repeat(seq(",", $.initializedIdentifier))),
functionSignature: $ => seq(optional($.type), $.identifier, $.formalParameterPart),
functionBody: $ => choice(seq("=>", $.expression, ";"), $.block, seq($.ASYNC, "=>", $.expression, ";"), seq(choice($.ASYNC, seq($.ASYNC, "*"), seq($.SYNC, "*")), $.block)),
block: $ => seq($.LBRACE, statements($), $.RBRACE),
formalParameterPart: $ => seq(optional($.typeParameters), $.formalParameterList),
formalParameterList: $ => choice(seq("(", ")"), seq("(", $.normalFormalParameters, optional(","), ")"), seq("(", $.normalFormalParameters, ",", $.optionalOrNamedFormalParameters, ")"), seq("(", $.optionalOrNamedFormalParameters, ")")),
normalFormalParameters: $ => seq($.normalFormalParameter, repeat(seq(",", $.normalFormalParameter))),
optionalOrNamedFormalParameters: $ => choice($.optionalPositionalFormalParameters, $.namedFormalParameters),
optionalPositionalFormalParameters: $ => seq("[", $.defaultFormalParameter, repeat(seq(",", $.defaultFormalParameter)), optional(","), "]"),
namedFormalParameters: $ => seq($.LBRACE, $.defaultNamedParameter, repeat(seq(",", $.defaultNamedParameter)), optional(","), $.RBRACE),
normalFormalParameter: $ => seq(metadata($), $.normalFormalParameterNoMetadata),
normalFormalParameterNoMetadata: $ => choice($.functionFormalParameter, $.fieldFormalParameter, $.simpleFormalParameter, $.superFormalParameter),
functionFormalParameter: $ => seq(optional($.COVARIANT), optional($.type), $.identifier, $.formalParameterPart, optional("?")),
simpleFormalParameter: $ => choice($.declaredIdentifier, seq(optional($.COVARIANT), $.identifier)),
fieldFormalParameter: $ => seq(optional($.finalConstVarOrType), $.THIS, ".", $.identifier, optional(seq($.formalParameterPart, optional("?")))),
superFormalParameter: $ => seq(optional($.type), $.SUPER, ".", $.identifier, optional(seq($.formalParameterPart, optional("?")))),
defaultFormalParameter: $ => seq($.normalFormalParameter, optional(seq("=", $.expression))),
defaultNamedParameter: $ => seq(metadata($), optional($.REQUIRED), $.normalFormalParameterNoMetadata, optional(seq("=", $.expression))),
typeWithParameters: $ => seq($.typeIdentifier, optional($.typeParameters)),
classDeclaration: $ => choice(seq(choice(classModifiers($), $.mixinClassModifiers), $.CLASS, $.typeWithParameters, optional($.superclass), optional($.interfaces), $.LBRACE, repeat(seq(metadata($), $.classMemberDeclaration)), $.RBRACE), seq(classModifiers($), $.CLASS, $.mixinApplicationClass)),
mixinClassModifiers: $ => seq(optional($.ABSTRACT), optional($.BASE), $.MIXIN),
superclass: $ => choice(seq($.EXTENDS, $.typeNotVoidNotFunction, optional($.mixins)), $.mixins),
mixins: $ => seq($.WITH, $.typeNotVoidNotFunctionList),
interfaces: $ => seq($.IMPLEMENTS, $.typeNotVoidNotFunctionList),
classMemberDeclaration: $ => choice(seq($.methodSignature, $.functionBody), seq($.declaration, ";")),
mixinApplicationClass: $ => seq($.typeWithParameters, "=", $.mixinApplication, ";"),
mixinDeclaration: $ => seq(optional($.mixinModifier), $.MIXIN, $.typeIdentifier, optional($.typeParameters), optional(seq($.ON, $.typeNotVoidNotFunctionList)), optional($.interfaces), $.LBRACE, repeat(seq(metadata($), $.mixinMemberDeclaration)), $.RBRACE),
mixinModifier: $ => choice($.SEALED, $.BASE, $.INTERFACE, $.FINAL),
mixinMemberDeclaration: $ => $.classMemberDeclaration,
extensionTypeDeclaration: $ => seq($.EXTENSION, $.TYPE, optional($.CONST), $.typeWithParameters, $.representationDeclaration, optional($.interfaces), $.LBRACE, repeat(seq(metadata($), $.extensionTypeMemberDeclaration)), $.RBRACE),
representationDeclaration: $ => seq(optional(seq(".", $.identifierOrNew)), "(", metadata($), $.type, $.identifier, ")"),
extensionTypeMemberDeclaration: $ => $.classMemberDeclaration,
extensionDeclaration: $ => seq($.EXTENSION, optional($.typeIdentifierNotType), optional($.typeParameters), $.ON, $.type, $.LBRACE, repeat(seq(metadata($), $.extensionMemberDefinition)), $.RBRACE),
extensionMemberDefinition: $ => $.classMemberDeclaration,
methodSignature: $ => choice(seq($.constructorSignature, $.initializers), $.factoryConstructorSignature, seq(optional($.STATIC), $.functionSignature), seq(optional($.STATIC), $.getterSignature), seq(optional($.STATIC), $.setterSignature), $.operatorSignature, $.constructorSignature),
declaration: $ => choice(seq($.EXTERNAL, $.factoryConstructorSignature), seq($.EXTERNAL, $.constantConstructorSignature), seq($.EXTERNAL, $.constructorSignature), seq(optional(seq($.EXTERNAL, optional($.STATIC))), $.getterSignature), seq(optional(seq($.EXTERNAL, optional($.STATIC))), $.setterSignature), seq(optional(seq($.EXTERNAL, optional($.STATIC))), $.functionSignature), seq($.EXTERNAL, choice(seq(optional($.STATIC), $.finalVarOrType), seq($.COVARIANT, $.varOrType)), $.identifierList), seq($.ABSTRACT, choice($.finalVarOrType, seq($.COVARIANT, $.varOrType)), $.identifierList), seq(optional($.EXTERNAL), $.operatorSignature), seq($.STATIC, choice($.FINAL, $.CONST), optional($.type), $.staticFinalDeclarationList), seq($.STATIC, $.LATE, $.FINAL, optional($.type), $.initializedIdentifierList), seq($.STATIC, optional($.LATE), $.varOrType, $.initializedIdentifierList), seq($.COVARIANT, $.LATE, $.FINAL, optional($.type), $.identifierList), seq($.COVARIANT, optional($.LATE), $.varOrType, $.initializedIdentifierList), seq(optional($.LATE), choice(seq($.FINAL, optional($.type)), $.varOrType), $.initializedIdentifierList), $.redirectingFactoryConstructorSignature, seq($.constantConstructorSignature, optional(choice($.redirection, $.initializers))), seq($.constructorSignature, optional(choice($.redirection, $.initializers)))),
staticFinalDeclarationList: $ => seq($.staticFinalDeclaration, repeat(seq(",", $.staticFinalDeclaration))),
staticFinalDeclaration: $ => seq($.identifier, "=", $.expression),
operatorSignature: $ => seq(optional($.type), $.OPERATOR, $.operator, $.formalParameterList),
operator: $ => choice("~", $.binaryOperator, seq("[", "]"), seq("[", "]", "=")),
binaryOperator: $ => choice($.multiplicativeOperator, $.additiveOperator, $.shiftOperator, $.relationalOperator, "==", $.bitwiseOperator),
getterSignature: $ => seq(optional($.type), $.GET, $.identifier),
setterSignature: $ => seq(optional($.type), $.SET, $.identifier, $.formalParameterList),
constructorSignature: $ => seq($.constructorName, $.formalParameterList),
constructorName: $ => seq($.typeIdentifier, optional(seq(".", $.identifierOrNew))),
identifierOrNew: $ => choice($.identifier, $.NEW),
redirection: $ => seq(":", $.THIS, optional(seq(".", $.identifierOrNew)), $.arguments),
initializers: $ => seq(":", $.initializerListEntry, repeat(seq(",", $.initializerListEntry))),
initializerListEntry: $ => choice(seq($.SUPER, $.arguments), seq($.SUPER, ".", $.identifierOrNew, $.arguments), $.fieldInitializer, $.assertion),
fieldInitializer: $ => seq(optional(seq($.THIS, ".")), $.identifier, "=", $.initializerExpression),
initializerExpression: $ => choice($.throwExpression, seq($.assignableExpression, $.assignmentOperator, $.expression), $.conditionalExpression, $.cascade),
factoryConstructorSignature: $ => seq(optional($.CONST), $.FACTORY, $.constructorName, $.formalParameterList),
redirectingFactoryConstructorSignature: $ => seq(optional($.CONST), $.FACTORY, $.constructorName, $.formalParameterList, "=", $.constructorDesignation),
constantConstructorSignature: $ => seq($.CONST, $.constructorName, $.formalParameterList),
mixinApplication: $ => seq($.typeNotVoidNotFunction, $.mixins, optional($.interfaces)),
enumType: $ => seq($.ENUM, $.typeIdentifier, optional($.typeParameters), optional($.mixins), optional($.interfaces), $.LBRACE, $.enumEntry, repeat(seq(",", $.enumEntry)), optional(","), optional(seq(";", repeat(seq(metadata($), $.classMemberDeclaration)))), $.RBRACE),
enumEntry: $ => choice(seq(metadata($), $.identifier, optional($.argumentPart)), seq(metadata($), $.identifier, optional($.typeArguments), ".", $.identifierOrNew, $.arguments)),
typeParameter: $ => seq(metadata($), $.typeIdentifier, optional(seq($.EXTENDS, $.typeNotVoid))),
typeParameters: $ => seq("<", $.typeParameter, repeat(seq(",", $.typeParameter)), ">"),
metadatum: $ => choice(seq($.constructorDesignation, $.arguments), $.identifier, $.qualifiedName),
expression: $ => choice($.patternAssignment, $.functionExpression, $.throwExpression, seq($.assignableExpression, $.assignmentOperator, $.expression), $.conditionalExpression, $.cascade),
expressionWithoutCascade: $ => choice($.functionExpressionWithoutCascade, $.throwExpressionWithoutCascade, seq($.assignableExpression, $.assignmentOperator, $.expressionWithoutCascade), $.conditionalExpression),
expressionList: $ => seq($.expression, repeat(seq(",", $.expression))),
primary: $ => choice($.thisExpression, seq($.SUPER, $.unconditionalAssignableSelector), seq($.SUPER, $.argumentPart), $.functionPrimary, $.literal, $.identifier, $.newExpression, $.constObjectExpression, $.constructorInvocation, seq("(", $.expression, ")"), $.constructorTearoff, $.switchExpression),
constructorInvocation: $ => choice(seq($.typeName, $.typeArguments, ".", $.NEW, $.arguments), seq($.typeName, ".", $.NEW, $.arguments)),
literal: $ => choice($.nullLiteral, $.booleanLiteral, $.numericLiteral, $.stringLiteral, $.symbolLiteral, $.setOrMapLiteral, $.listLiteral, $.recordLiteral),
nullLiteral: $ => $.NULL,
numericLiteral: $ => choice($.NUMBER, $.HEX_NUMBER),
booleanLiteral: $ => choice($.TRUE, $.FALSE),
stringLiteral: $ => repeat1(choice($.multiLineString, $.singleLineString)),
setOrMapLiteral: $ => seq(optional($.CONST), optional($.typeArguments), $.LBRACE, optional($.elements), $.RBRACE),
listLiteral: $ => seq(optional($.CONST), optional($.typeArguments), "[", optional($.elements), "]"),
recordLiteral: $ => seq(optional($.CONST), $.recordLiteralNoConst),
recordLiteralNoConst: $ => choice(seq("(", ")"), seq("(", $.expression, ",", ")"), seq("(", $.label, $.expression, optional(","), ")"), seq("(", $.recordField, repeat1(seq(",", $.recordField)), optional(","), ")")),
recordField: $ => seq(optional($.label), $.expression),
elements: $ => seq($.element, repeat(seq(",", $.element)), optional(",")),
element: $ => choice($.expressionElement, $.mapElement, $.spreadElement, $.ifElement, $.forElement),
expressionElement: $ => $.expression,
mapElement: $ => seq($.expression, ":", $.expression),
spreadElement: $ => seq(choice("...", "...?"), $.expression),
ifElement: $ => seq($.ifCondition, $.element, optional(seq($.ELSE, $.element))),
forElement: $ => seq(optional($.AWAIT), $.FOR, "(", $.forLoopParts, ")", $.element),
constructorTearoff: $ => seq($.typeName, optional($.typeArguments), ".", $.NEW),
switchExpression: $ => seq($.SWITCH, "(", $.expression, ")", $.LBRACE, $.switchExpressionCase, repeat(seq(",", $.switchExpressionCase)), optional(","), $.RBRACE),
switchExpressionCase: $ => seq($.guardedPattern, "=>", $.expression),
throwExpression: $ => seq($.THROW, $.expression),
throwExpressionWithoutCascade: $ => seq($.THROW, $.expressionWithoutCascade),
functionExpression: $ => seq($.formalParameterPart, $.functionExpressionBody),
functionExpressionBody: $ => choice(seq("=>", $.expression), seq($.ASYNC, "=>", $.expression)),
functionExpressionWithoutCascade: $ => seq($.formalParameterPart, $.functionExpressionWithoutCascadeBody),
functionExpressionWithoutCascadeBody: $ => choice(seq("=>", $.expressionWithoutCascade), seq($.ASYNC, "=>", $.expressionWithoutCascade)),
functionPrimary: $ => seq($.formalParameterPart, $.functionPrimaryBody),
functionPrimaryBody: $ => choice($.block, seq(choice($.ASYNC, seq($.ASYNC, "*"), seq($.SYNC, "*")), $.block)),
thisExpression: $ => $.THIS,
newExpression: $ => seq($.NEW, $.constructorDesignation, $.arguments),
constObjectExpression: $ => seq($.CONST, $.constructorDesignation, $.arguments),
arguments: $ => seq("(", optional(seq($.argumentList, optional(","))), ")"),
argumentList: $ => seq($.argument, repeat(seq(",", $.argument))),
argument: $ => seq(optional($.label), $.expression),
cascade: $ => seq(seq($.conditionalExpression, choice("?..", ".."), $.cascadeSection), repeat(seq("..", $.cascadeSection))),
cascadeSection: $ => seq($.cascadeSelector, cascadeSectionTail($)),
cascadeSelector: $ => choice(seq("[", $.expression, "]"), $.identifier),
cascadeAssignment: $ => seq($.assignmentOperator, $.expressionWithoutCascade),
assignmentOperator: $ => choice("=", $.compoundAssignmentOperator),
compoundAssignmentOperator: $ => choice("*=", "/=", "~/=", "%=", "+=", "-=", "<<=", seq(">", ">", ">", "="), seq(">", ">", "="), "&=", "^=", "|=", "??="),
conditionalExpression: $ => seq($.ifNullExpression, optional(seq("?", $.expressionWithoutCascade, ":", $.expressionWithoutCascade))),
ifNullExpression: $ => seq($.logicalOrExpression, repeat(seq("??", $.logicalOrExpression))),
logicalOrExpression: $ => seq($.logicalAndExpression, repeat(seq("||", $.logicalAndExpression))),
logicalAndExpression: $ => seq($.equalityExpression, repeat(seq("&&", $.equalityExpression))),
equalityExpression: $ => choice(seq($.relationalExpression, optional(seq($.equalityOperator, $.relationalExpression))), seq($.SUPER, $.equalityOperator, $.relationalExpression)),
equalityOperator: $ => choice("==", "!="),
relationalExpression: $ => choice(seq($.bitwiseOrExpression, optional(choice($.typeTest, $.typeCast, seq($.relationalOperator, $.bitwiseOrExpression)))), seq($.SUPER, $.relationalOperator, $.bitwiseOrExpression)),
relationalOperator: $ => choice(seq(">", "="), ">", "<=", "<"),
bitwiseOrExpression: $ => choice(seq($.bitwiseXorExpression, repeat(seq("|", $.bitwiseXorExpression))), seq($.SUPER, repeat1(seq("|", $.bitwiseXorExpression)))),
bitwiseXorExpression: $ => choice(seq($.bitwiseAndExpression, repeat(seq("^", $.bitwiseAndExpression))), seq($.SUPER, repeat1(seq("^", $.bitwiseAndExpression)))),
bitwiseAndExpression: $ => choice(seq($.shiftExpression, repeat(seq("&", $.shiftExpression))), seq($.SUPER, repeat1(seq("&", $.shiftExpression)))),
bitwiseOperator: $ => choice("&", "^", "|"),
shiftExpression: $ => choice(seq($.additiveExpression, repeat(seq($.shiftOperator, $.additiveExpression))), seq($.SUPER, repeat1(seq($.shiftOperator, $.additiveExpression)))),
shiftOperator: $ => choice("<<", seq(">", ">", ">"), seq(">", ">")),
additiveExpression: $ => choice(seq($.multiplicativeExpression, repeat(seq($.additiveOperator, $.multiplicativeExpression))), seq($.SUPER, repeat1(seq($.additiveOperator, $.multiplicativeExpression)))),
additiveOperator: $ => choice("+", "-"),
multiplicativeExpression: $ => choice(seq($.unaryExpression, repeat(seq($.multiplicativeOperator, $.unaryExpression))), seq($.SUPER, repeat1(seq($.multiplicativeOperator, $.unaryExpression)))),
multiplicativeOperator: $ => choice("*", "/", "%", "~/"),
unaryExpression: $ => choice(seq($.prefixOperator, $.unaryExpression), $.awaitExpression, $.postfixExpression, seq(choice($.minusOperator, $.tildeOperator), $.SUPER), seq($.incrementOperator, $.assignableExpression)),
prefixOperator: $ => choice($.minusOperator, $.negationOperator, $.tildeOperator),
minusOperator: $ => "-",
negationOperator: $ => "!",
tildeOperator: $ => "~",
awaitExpression: $ => seq($.AWAIT, $.unaryExpression),
postfixExpression: $ => choice(seq($.assignableExpression, $.postfixOperator), seq($.primary, repeat($.selector))),
postfixOperator: $ => $.incrementOperator,
selector: $ => choice("!", $.assignableSelector, $.argumentPart, $.typeArguments),
argumentPart: $ => seq(optional($.typeArguments), $.arguments),
incrementOperator: $ => choice("++", "--"),
assignableExpression: $ => choice(seq($.SUPER, $.unconditionalAssignableSelector), seq($.primary, $.assignableSelectorPart), $.identifier),
assignableSelectorPart: $ => seq(repeat($.selector), $.assignableSelector),
unconditionalAssignableSelector: $ => choice(seq("[", $.expression, "]"), seq(".", $.identifier)),
assignableSelector: $ => choice($.unconditionalAssignableSelector, seq("?.", $.identifier), seq("?", "[", $.expression, "]")),
identifier: $ => choice($.IDENTIFIER, $.builtInIdentifier, $.otherIdentifier, choice($.AWAIT, $.YIELD)),
qualifiedName: $ => choice(seq($.typeIdentifier, ".", $.identifierOrNew), seq($.typeIdentifier, ".", $.typeIdentifier, ".", $.identifierOrNew)),
typeIdentifierNotType: $ => choice($.IDENTIFIER, $.DYNAMIC, $.otherIdentifierNotType, choice($.AWAIT, $.YIELD)),
typeIdentifier: $ => choice($.typeIdentifierNotType, $.TYPE),
typeTest: $ => seq($.isOperator, $.typeNotVoid),
isOperator: $ => seq($.IS, optional("!")),
typeCast: $ => seq($.asOperator, $.typeNotVoid),
asOperator: $ => $.AS,
pattern: $ => $.logicalOrPattern,
logicalOrPattern: $ => seq($.logicalAndPattern, repeat(seq("||", $.logicalAndPattern))),
logicalAndPattern: $ => seq($.relationalPattern, repeat(seq("&&", $.relationalPattern))),
relationalPattern: $ => choice(seq(choice($.equalityOperator, $.relationalOperator), $.bitwiseOrExpression), $.unaryPattern),
unaryPattern: $ => choice($.castPattern, $.nullCheckPattern, $.nullAssertPattern, $.primaryPattern),
primaryPattern: $ => choice($.constantPattern, $.variablePattern, $.parenthesizedPattern, $.listPattern, $.mapPattern, $.recordPattern, $.objectPattern),
castPattern: $ => seq($.primaryPattern, $.AS, $.type),
nullCheckPattern: $ => seq($.primaryPattern, "?"),
nullAssertPattern: $ => seq($.primaryPattern, "!"),
constantPattern: $ => choice($.booleanLiteral, $.nullLiteral, seq(optional("-"), $.numericLiteral), $.stringLiteral, $.symbolLiteral, $.identifier, $.qualifiedName, $.constObjectExpression, seq($.CONST, optional($.typeArguments), "[", optional($.elements), "]"), seq($.CONST, optional($.typeArguments), $.LBRACE, optional($.elements), $.RBRACE), seq($.CONST, "(", $.expression, ")")),
variablePattern: $ => seq(optional(choice($.VAR, $.FINAL, seq(optional($.FINAL), $.type))), $.identifier),
parenthesizedPattern: $ => seq("(", $.pattern, ")"),
listPattern: $ => seq(optional($.typeArguments), "[", optional($.listPatternElements), "]"),
listPatternElements: $ => seq($.listPatternElement, repeat(seq(",", $.listPatternElement)), optional(",")),
listPatternElement: $ => choice($.pattern, $.restPattern),
restPattern: $ => seq("...", optional($.pattern)),
mapPattern: $ => seq(optional($.typeArguments), $.LBRACE, optional($.mapPatternEntries), $.RBRACE),
mapPatternEntries: $ => seq($.mapPatternEntry, repeat(seq(",", $.mapPatternEntry)), optional(",")),
mapPatternEntry: $ => choice(seq($.expression, ":", $.pattern), "..."),
recordPattern: $ => seq("(", optional($.patternFields), ")"),
patternFields: $ => seq($.patternField, repeat(seq(",", $.patternField)), optional(",")),
patternField: $ => seq(optional(seq(optional($.identifier), ":")), $.pattern),
objectPattern: $ => seq(choice(seq($.typeName, optional($.typeArguments)), $.typeNamedFunction), "(", optional($.patternFields), ")"),
patternVariableDeclaration: $ => seq(choice($.FINAL, $.VAR), $.outerPattern, "=", $.expression),
outerPattern: $ => choice($.parenthesizedPattern, $.listPattern, $.mapPattern, $.recordPattern, $.objectPattern),
patternAssignment: $ => seq($.outerPattern, "=", $.expression),
statement: $ => seq(repeat($.label), $.nonLabelledStatement),
nonLabelledStatement: $ => choice($.block, $.localVariableDeclaration, $.forStatement, $.whileStatement, $.doStatement, $.switchStatement, $.ifStatement, $.rethrowStatement, $.tryStatement, $.breakStatement, $.continueStatement, $.returnStatement, $.localFunctionDeclaration, $.assertStatement, $.yieldStatement, $.yieldEachStatement, $.expressionStatement),
expressionStatement: $ => seq(optional($.expression), ";"),
localVariableDeclaration: $ => choice(seq(metadata($), $.initializedVariableDeclaration, ";"), seq(metadata($), $.patternVariableDeclaration, ";")),
initializedVariableDeclaration: $ => seq($.declaredIdentifier, optional(seq("=", $.expression)), repeat(seq(",", $.initializedIdentifier))),
localFunctionDeclaration: $ => seq(metadata($), $.functionSignature, $.functionBody),
ifStatement: $ => seq($.ifCondition, $.statement, optional(seq($.ELSE, $.statement))),
ifCondition: $ => seq($.IF, "(", $.expression, optional(seq($.CASE, $.guardedPattern)), ")"),
forStatement: $ => seq(optional($.AWAIT), $.FOR, "(", $.forLoopParts, ")", $.statement),
forLoopParts: $ => choice(seq(metadata($), $.declaredIdentifier, $.IN, $.expression), seq(metadata($), $.identifier, $.IN, $.expression), seq($.forInitializerStatement, optional($.expression), ";", optional($.expressionList)), seq(metadata($), choice($.FINAL, $.VAR), $.outerPattern, $.IN, $.expression)),
forInitializerStatement: $ => choice($.localVariableDeclaration, seq(optional($.expression), ";")),
whileStatement: $ => seq($.WHILE, "(", $.expression, ")", $.statement),
doStatement: $ => seq($.DO, $.statement, $.WHILE, "(", $.expression, ")", ";"),
switchStatement: $ => seq($.SWITCH, "(", $.expression, ")", $.LBRACE, repeat($.switchStatementCase), optional($.switchStatementDefault), $.RBRACE),
switchStatementCase: $ => seq(repeat($.label), $.CASE, $.guardedPattern, ":", statements($)),
guardedPattern: $ => seq($.pattern, optional(seq($.WHEN, $.expression))),
switchStatementDefault: $ => seq(repeat($.label), $.DEFAULT, ":", statements($)),
rethrowStatement: $ => seq($.RETHROW, ";"),
tryStatement: $ => seq($.TRY, $.block, choice(seq(repeat1($.onPart), optional($.finallyPart)), $.finallyPart)),
onPart: $ => choice(seq($.catchPart, $.block), seq($.ON, $.typeNotVoid, optional($.catchPart), $.block)),
catchPart: $ => seq($.CATCH, "(", $.identifier, optional(seq(",", $.identifier)), ")"),
finallyPart: $ => seq($.FINALLY, $.block),
returnStatement: $ => seq($.RETURN, optional($.expression), ";"),
label: $ => seq($.identifier, ":"),
breakStatement: $ => seq($.BREAK, optional($.identifier), ";"),
continueStatement: $ => seq($.CONTINUE, optional($.identifier), ";"),
yieldStatement: $ => seq($.YIELD, $.expression, ";"),
yieldEachStatement: $ => seq($.YIELD, "*", $.expression, ";"),
assertStatement: $ => seq($.assertion, ";"),
assertion: $ => seq($.ASSERT, "(", $.expression, optional(seq(",", $.expression)), optional(","), ")"),
libraryName: $ => seq(metadata($), $.LIBRARY, optional($.dottedIdentifierList), ";"),
dottedIdentifierList: $ => seq($.identifier, repeat(seq(".", $.identifier))),
importOrExport: $ => choice($.libraryImport, $.libraryExport),
libraryImport: $ => seq(metadata($), $.importSpecification),
importSpecification: $ => seq($.IMPORT, $.configurableUri, optional(seq(optional($.DEFERRED), $.AS, $.typeIdentifier)), repeat($.combinator), ";"),
combinator: $ => choice(seq($.SHOW, $.identifierList), seq($.HIDE, $.identifierList)),
identifierList: $ => seq($.identifier, repeat(seq(",", $.identifier))),
libraryExport: $ => seq(metadata($), $.EXPORT, $.configurableUri, repeat($.combinator), ";"),
partDirective: $ => seq(metadata($), $.PART, $.uri, ";"),
partHeader: $ => seq(metadata($), $.PART, $.OF, choice($.dottedIdentifierList, $.uri), ";"),
partDeclaration: $ => seq(optional($.FEFF), $.partHeader, repeat(seq(metadata($), $.topLevelDefinition))),
uri: $ => $.stringLiteral,
configurableUri: $ => seq($.uri, repeat($.configurationUri)),
configurationUri: $ => seq($.IF, "(", $.uriTest, ")", $.uri),
uriTest: $ => seq($.dottedIdentifierList, optional(seq("==", $.stringLiteral))),
type: $ => choice(seq($.functionType, optional("?")), $.typeNotFunction),
typeNotVoid: $ => choice(seq($.functionType, optional("?")), seq($.recordType, optional("?")), seq($.typeNotVoidNotFunction, optional("?"))),
typeNotFunction: $ => choice(seq($.typeNotVoidNotFunction, optional("?")), seq($.recordType, optional("?")), $.VOID),
typeNamedFunction: $ => seq(optional(seq($.typeIdentifier, ".")), $.FUNCTION),
typeNotVoidNotFunction: $ => choice(seq($.typeName, optional($.typeArguments)), $.typeNamedFunction),
typeName: $ => seq($.typeIdentifier, optional(seq(".", $.typeIdentifier))),
typeArguments: $ => seq("<", $.typeList, ">"),
typeList: $ => seq($.type, repeat(seq(",", $.type))),
recordType: $ => choice(seq("(", ")"), seq("(", $.recordTypeFields, ",", $.recordTypeNamedFields, ")"), seq("(", $.recordTypeFields, optional(","), ")"), seq("(", $.recordTypeNamedFields, ")")),
recordTypeFields: $ => seq($.recordTypeField, repeat(seq(",", $.recordTypeField))),
recordTypeField: $ => seq(metadata($), $.type, optional($.identifier)),
recordTypeNamedFields: $ => seq($.LBRACE, $.recordTypeNamedField, repeat(seq(",", $.recordTypeNamedField)), optional(","), $.RBRACE),
recordTypeNamedField: $ => seq(metadata($), $.typedIdentifier),
typeNotVoidNotFunctionList: $ => seq($.typeNotVoidNotFunction, repeat(seq(",", $.typeNotVoidNotFunction))),
typeAlias: $ => choice(seq($.TYPEDEF, $.typeIdentifier, optional($.typeParameters), "=", $.type, ";"), seq($.TYPEDEF, $.functionTypeAlias)),
functionTypeAlias: $ => seq($.functionPrefix, $.formalParameterPart, ";"),
functionPrefix: $ => choice(seq($.type, $.identifier), $.identifier),
functionTypeTail: $ => seq($.FUNCTION, optional($.typeParameters), $.parameterTypeList),
functionTypeTails: $ => seq(repeat(seq($.functionTypeTail, optional("?"))), $.functionTypeTail),
functionType: $ => seq(optional($.typeNotFunction), $.functionTypeTails),
parameterTypeList: $ => choice(seq("(", ")"), seq("(", $.normalParameterTypes, ",", $.optionalParameterTypes, ")"), seq("(", $.normalParameterTypes, optional(","), ")"), seq("(", $.optionalParameterTypes, ")")),
normalParameterTypes: $ => seq($.normalParameterType, repeat(seq(",", $.normalParameterType))),
normalParameterType: $ => choice(seq(metadata($), $.typedIdentifier), seq(metadata($), $.type)),
optionalParameterTypes: $ => choice($.optionalPositionalParameterTypes, $.namedParameterTypes),
optionalPositionalParameterTypes: $ => seq("[", $.normalParameterTypes, optional(","), "]"),
namedParameterTypes: $ => seq($.LBRACE, $.namedParameterType, repeat(seq(",", $.namedParameterType)), optional(","), $.RBRACE),
namedParameterType: $ => seq(metadata($), optional($.REQUIRED), $.typedIdentifier),
typedIdentifier: $ => seq($.type, $.identifier),
constructorDesignation: $ => choice($.typeIdentifier, $.qualifiedName, seq($.typeName, $.typeArguments, optional(seq(".", $.identifierOrNew)))),
symbolLiteral: $ => seq("#", choice($.operator, seq($.identifier, repeat(seq(".", $.identifier))), $.VOID)),
singleLineString: $ => choice($.RAW_SINGLE_LINE_STRING, $.SINGLE_LINE_STRING_SQ_BEGIN_END, seq($.SINGLE_LINE_STRING_SQ_BEGIN_MID, $.expression, repeat(seq($.SINGLE_LINE_STRING_SQ_MID_MID, $.expression)), $.SINGLE_LINE_STRING_SQ_MID_END), $.SINGLE_LINE_STRING_DQ_BEGIN_END, seq($.SINGLE_LINE_STRING_DQ_BEGIN_MID, $.expression, repeat(seq($.SINGLE_LINE_STRING_DQ_MID_MID, $.expression)), $.SINGLE_LINE_STRING_DQ_MID_END)),
multiLineString: $ => choice($.RAW_MULTI_LINE_STRING, $.MULTI_LINE_STRING_SQ_BEGIN_END, seq($.MULTI_LINE_STRING_SQ_BEGIN_MID, $.expression, repeat(seq($.MULTI_LINE_STRING_SQ_MID_MID, $.expression)), $.MULTI_LINE_STRING_SQ_MID_END), $.MULTI_LINE_STRING_DQ_BEGIN_END, seq($.MULTI_LINE_STRING_DQ_BEGIN_MID, $.expression, repeat(seq($.MULTI_LINE_STRING_DQ_MID_MID, $.expression)), $.MULTI_LINE_STRING_DQ_MID_END)),
reservedWord: $ => choice($.ASSERT, $.BREAK, $.CASE, $.CATCH, $.CLASS, $.CONST, $.CONTINUE, $.DEFAULT, $.DO, $.ELSE, $.ENUM, $.EXTENDS, $.FALSE, $.FINAL, $.FINALLY, $.FOR, $.IF, $.IN, $.IS, $.NEW, $.NULL, $.RETHROW, $.RETURN, $.SUPER, $.SWITCH, $.THIS, $.THROW, $.TRUE, $.TRY, $.VAR, $.VOID, $.WHILE, $.WITH),
builtInIdentifier: $ => choice($.ABSTRACT, $.AS, $.COVARIANT, $.DEFERRED, $.DYNAMIC, $.EXPORT, $.EXTENSION, $.EXTERNAL, $.FACTORY, $.FUNCTION, $.GET, $.IMPLEMENTS, $.IMPORT, $.INTERFACE, $.LATE, $.LIBRARY, $.OPERATOR, $.MIXIN, $.PART, $.REQUIRED, $.SET, $.STATIC, $.TYPEDEF),
otherIdentifierNotType: $ => choice($.ASYNC, $.BASE, $.HIDE, $.OF, $.ON, $.SEALED, $.SHOW, $.SYNC, $.WHEN),
otherIdentifier: $ => choice($.otherIdentifierNotType, $.TYPE),
_MULTI_LINE_COMMENT: $ => seq("/*", repeat(choice(/./)), "*/"),
// Lexer rules
ASSERT: $ => token("assert"),
BREAK: $ => token("break"),
CASE: $ => token("case"),
CATCH: $ => token("catch"),
CLASS: $ => token("class"),
CONST: $ => token("const"),
CONTINUE: $ => token("continue"),
DEFAULT: $ => token("default"),
DO: $ => token("do"),
ELSE: $ => token("else"),
ENUM: $ => token("enum"),
EXTENDS: $ => token("extends"),
FALSE: $ => token("false"),
FINAL: $ => token("final"),
FINALLY: $ => token("finally"),
FOR: $ => token("for"),
IF: $ => token("if"),
IN: $ => token("in"),
IS: $ => token("is"),
NEW: $ => token("new"),
NULL: $ => token("null"),
RETHROW: $ => token("rethrow"),
RETURN: $ => token("return"),
SUPER: $ => token("super"),
SWITCH: $ => token("switch"),
THIS: $ => token("this"),
THROW: $ => token("throw"),
TRUE: $ => token("true"),
TRY: $ => token("try"),
VAR: $ => token("var"),
VOID: $ => token("void"),
WHILE: $ => token("while"),
WITH: $ => token("with"),
ABSTRACT: $ => token("abstract"),
AS: $ => token("as"),
COVARIANT: $ => token("covariant"),
DEFERRED: $ => token("deferred"),
DYNAMIC: $ => token("dynamic"),
EXPORT: $ => token("export"),
EXTENSION: $ => token("extension"),
EXTERNAL: $ => token("external"),
FACTORY: $ => token("factory"),
FUNCTION: $ => token("Function"),
GET: $ => token("get"),
IMPLEMENTS: $ => token("implements"),
IMPORT: $ => token("import"),
INTERFACE: $ => token("interface"),
LATE: $ => token("late"),
LIBRARY: $ => token("library"),
OPERATOR: $ => token("operator"),
MIXIN: $ => token("mixin"),
PART: $ => token("part"),
REQUIRED: $ => token("required"),
SET: $ => token("set"),
STATIC: $ => token("static"),
TYPEDEF: $ => token("typedef"),
AWAIT: $ => token("await"),
YIELD: $ => token("yield"),
ASYNC: $ => token("async"),
BASE: $ => token("base"),
HIDE: $ => token("hide"),
OF: $ => token("of"),
ON: $ => token("on"),
SEALED: $ => token("sealed"),
SHOW: $ => token("show"),
SYNC: $ => token("sync"),
TYPE: $ => token("type"),
WHEN: $ => token("when"),
NUMBER: $ => token(choice(seq(repeat1(DIGIT()), ".", repeat1(DIGIT()), optional(EXPONENT())), seq(repeat1(DIGIT()), optional(EXPONENT())), seq(".", repeat1(DIGIT()), optional(EXPONENT())))),
HEX_NUMBER: $ => token(choice(seq("0x", repeat1(HEX_DIGIT())), seq("0X", repeat1(HEX_DIGIT())))),
RAW_SINGLE_LINE_STRING: $ => token(choice(seq("r", "'", repeat(/[^'\r\n]/), "'"), seq("r", "\"", repeat(/[^"\r\n]/), "\""))),
RAW_MULTI_LINE_STRING: $ => token(choice(seq("r", "\"\"\"", anythingBut("\"\"\""), "\"\"\""), seq("r", "'''", anythingBut("'''"), "'''"))),
SINGLE_LINE_STRING_SQ_BEGIN_END: $ => token(seq("'", repeat(STRING_CONTENT_SQ()), "'")),
SINGLE_LINE_STRING_SQ_BEGIN_MID: $ => token(seq("'", repeat(STRING_CONTENT_SQ()), "${")),
SINGLE_LINE_STRING_SQ_MID_MID: $ => token(seq("}", repeat(STRING_CONTENT_SQ()), "${")),
SINGLE_LINE_STRING_SQ_MID_END: $ => token(seq("}", repeat(STRING_CONTENT_SQ()), "'")),
SINGLE_LINE_STRING_DQ_BEGIN_END: $ => token(seq("\"", repeat(STRING_CONTENT_DQ()), "\"")),
SINGLE_LINE_STRING_DQ_BEGIN_MID: $ => token(seq("\"", repeat(STRING_CONTENT_DQ()), "${")),
SINGLE_LINE_STRING_DQ_MID_MID: $ => token(seq("}", repeat(STRING_CONTENT_DQ()), "${")),
SINGLE_LINE_STRING_DQ_MID_END: $ => token(seq("}", repeat(STRING_CONTENT_DQ()), "\"")),
MULTI_LINE_STRING_SQ_BEGIN_END: $ => token(seq("'''", repeat(STRING_CONTENT_TSQ()), "'''")),
MULTI_LINE_STRING_SQ_BEGIN_MID: $ => token(seq("'''", repeat(STRING_CONTENT_TSQ()), QUOTES_SQ(), "${")),
MULTI_LINE_STRING_SQ_MID_MID: $ => token(seq("}", repeat(STRING_CONTENT_TSQ()), QUOTES_SQ(), "${")),
MULTI_LINE_STRING_SQ_MID_END: $ => token(seq("}", repeat(STRING_CONTENT_TSQ()), "'''")),
MULTI_LINE_STRING_DQ_BEGIN_END: $ => token(seq("\"\"\"", repeat(STRING_CONTENT_TDQ()), "\"\"\"")),
MULTI_LINE_STRING_DQ_BEGIN_MID: $ => token(seq("\"\"\"", repeat(STRING_CONTENT_TDQ()), QUOTES_DQ(), "${")),
MULTI_LINE_STRING_DQ_MID_MID: $ => token(seq("}", repeat(STRING_CONTENT_TDQ()), QUOTES_DQ(), "${")),
MULTI_LINE_STRING_DQ_MID_END: $ => token(seq("}", repeat(STRING_CONTENT_TDQ()), "\"\"\"")),
LBRACE: $ => token("{"),
RBRACE: $ => token("}"),
SCRIPT_TAG: $ => token(seq("#!", repeat(/[^\r\n]/), NEWLINE())),
IDENTIFIER: $ => token(seq(IDENTIFIER_START(), repeat(IDENTIFIER_PART()))),
_SINGLE_LINE_COMMENT: $ => token(seq("//", repeat(/[^\r\n]/), optional(NEWLINE()))),
FEFF: $ => token("\uFEFF"),
_WS: $ => token(repeat1(/[ \t\r\n]/)),
},
// Conflicts
conflicts: $ => [
[$.topLevelDefinition, $.mixinModifier],
[$.typeIdentifierNotType, $.builtInIdentifier],
[$.extensionDeclaration, $.builtInIdentifier],
[$.topLevelDefinition, $.builtInIdentifier],
[$.functionTypeTail, $.builtInIdentifier],
[$.typeAlias, $.builtInIdentifier],
[$.identifier, $.typeIdentifierNotType],
[$.mixinClassModifiers, $.mixinModifier, $.otherIdentifierNotType],
[$.mixinModifier, $.otherIdentifierNotType],
[$.typeIdentifier, $.otherIdentifier],
[$.varOrType, $.functionSignature],
[$.varOrType, $.functionSignature, $.getterSignature],
[$.varOrType, $.functionSignature, $.setterSignature],
[$.type, $.functionType],
[$.functionTypeTails],
[$.typeIdentifierNotType, $.otherIdentifier],
[$.metadatum, $.constructorDesignation],
[$.recordTypeFields],
[$.extensionDeclaration, $.otherIdentifierNotType],
[$.finalVarOrType],
[$.typeName, $.typeAlias],
[$.typeNamedFunction, $.builtInIdentifier],
[$.awaitExpression, $.identifier, $.typeIdentifierNotType],
[$.awaitExpression, $.identifier],
[$.postfixExpression, $.assignableExpression],
[$.shiftExpression],
[$.unaryExpression, $.prefixOperator],
[$.primary, $.assignableExpression],
[$.typeNamedFunction, $.typeName],
[$.normalParameterTypes],
[$.finalConstVarOrType, $.constObjectExpression],
[$.finalConstVarOrType],
[$.finalConstVarOrType, $.patternVariableDeclaration],
[$.varOrType, $.patternVariableDeclaration],
[$.declaredIdentifier, $.builtInIdentifier],
[$.typeNamedFunction, $.functionTypeTail, $.builtInIdentifier],
[$.finalConstVarOrType, $.builtInIdentifier],
[$.awaitExpression, $.typeIdentifierNotType],
[$.identifier, $.yieldEachStatement],
[$.identifier, $.typeIdentifierNotType, $.yieldStatement],
[$.identifier, $.yieldStatement],
[$.typeIdentifierNotType, $.yieldStatement],
[$.functionSignature, $.primary],
[$.declaredIdentifier, $.functionFormalParameter, $.builtInIdentifier],
[$.normalFormalParameters],
[$.varOrType, $.functionFormalParameter],
[$.argumentList],
[$.declaration, $.builtInIdentifier],
[$.operatorSignature, $.builtInIdentifier],
[$.methodSignature, $.declaration, $.builtInIdentifier],
[$.varOrType, $.functionSignature, $.operatorSignature],
[$.relationalOperator, $.typeArguments],
[$.typeParameters, $.relationalOperator, $.typeArguments],
[$.minusOperator, $.constantPattern],
[$.finalConstVarOrType, $.variablePattern],
[$.fieldFormalParameter, $.thisExpression],
[$.varOrType, $.variablePattern],
[$.functionFormalParameter, $.simpleFormalParameter, $.builtInIdentifier],
[$.recordLiteralNoConst, $.recordField],
[$.literal, $.constantPattern],
[$.primary, $.constantPattern],
[$.simpleFormalParameter, $.primary, $.constantPattern, $.variablePattern],
[$.functionFormalParameter, $.primary],
[$.primary, $.constantPattern, $.variablePattern],
[$.qualifiedName, $.typeNamedFunction, $.typeName],
[$.parenthesizedPattern, $.patternField],
[$.varOrType, $.functionFormalParameter, $.variablePattern],
[$.typeParameter, $.typeName],
[$.relationalOperator, $.shiftOperator],
[$.symbolLiteral],
[$.typeName],
[$.selector, $.assignableSelectorPart],
[$.selector, $.argumentPart],
[$.postfixExpression, $.assignableSelectorPart],
[$.postfixExpression],
[$.recordLiteralNoConst, $.recordType],
[$.formalParameterList, $.recordType],
[$.varOrType, $.functionFormalParameter, $.variablePattern, $.recordTypeField],
[$.typeNamedFunction, $.functionTypeTail],
[$.block, $.setOrMapLiteral],
[$.primary, $.label],
[$.defaultNamedParameter, $.builtInIdentifier],
[$.recordLiteralNoConst, $.recordPattern],
[$.recordLiteralNoConst, $.recordPattern, $.recordType],
[$.listLiteral, $.listPattern],
[$.simpleFormalParameter, $.assignableExpression],
[$.constantPattern, $.variablePattern],
[$.setOrMapLiteral, $.mapPattern],
[$.simpleFormalParameter, $.primary],
[$.patternField, $.label],
[$.shiftOperator],
[$.typeNotVoid, $.typeNotFunction],
[$.typeNotVoid],
[$.constructorInvocation, $.constructorTearoff],
[$.varOrType, $.functionFormalParameter, $.typedIdentifier],
[$.variablePattern, $.recordTypeField],
[$.varOrType, $.functionFormalParameter, $.recordTypeField],
[$.finalConstVarOrType, $.patternVariableDeclaration, $.forLoopParts],
[$.varOrType, $.patternVariableDeclaration, $.forLoopParts],
[$.tryStatement],
[$.ifStatement],
[$.recordPattern, $.recordType],
[$.listLiteral, $.constantPattern],
[$.setOrMapLiteral, $.constantPattern],
[$.superFormalParameter, $.unconditionalAssignableSelector],
[$.qualifiedName, $.typeName],
[$.ifElement],
[$.formalParameterList, $.recordLiteralNoConst],
[$.switchStatementCase]
]
});
