<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Dart support for Tree Sitter | tree-sitter grammar for Dart, automatically converted from the spec parser.</title>
<meta name="generator" content="Jekyll v3.9.5" />
<meta property="og:title" content="Dart support for Tree Sitter" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="tree-sitter grammar for Dart, automatically converted from the spec parser." />
<meta property="og:description" content="tree-sitter grammar for Dart, automatically converted from the spec parser." />
<link rel="canonical" href="http://localhost:4000/tree-sitter-dart/" />
<meta property="og:url" content="http://localhost:4000/tree-sitter-dart/" />
<meta property="og:site_name" content="Dart support for Tree Sitter" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Dart support for Tree Sitter" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","description":"tree-sitter grammar for Dart, automatically converted from the spec parser.","headline":"Dart support for Tree Sitter","name":"Dart support for Tree Sitter","url":"http://localhost:4000/tree-sitter-dart/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/tree-sitter-dart/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/tree-sitter-dart/feed.xml" title="Dart support for Tree Sitter" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/tree-sitter-dart/">Dart support for Tree Sitter</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/tree-sitter-dart/playground.html">Playground</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home"><p>Experimental support for Dart grammar for tree-sitter.</p>

<h1 id="overview">Overview</h1>

<p>Unlike the existing <a href="https://github.com/UserNobody14/tree-sitter-dart">tree-sitter-dart</a> project,
this one is fully automatically converted from the
<a href="https://github.com/dart-lang/sdk/blob/main/tools/spec_parser/Dart.g">Dart spec grammar</a>,
defined using <a href="https://www.antlr.org/">ANTLR</a> (currenly based on v0.40, copied from
<a href="https://github.com/dart-lang/sdk/commit/e9df8dceab89790ddc55c8d0ed388fcfe8fe879f">commit</a>).</p>

<p>This has both advantages:</p>

<ul>
  <li>Better coverage, in theory we should support as much Dart as the spec parser (but see <a href="#known-issues">Known Issues</a> below)</li>
  <li>Once the language evolves and the spec parser is updated, we could simply re-generate</li>
</ul>

<p>and disadvatanges:</p>

<ul>
  <li>ANTLR is LL($\infty$), while tree-sitter is GLR, that means the grammar is structured in
a very differnt way, and direct translation both stretches tree-sitter generation and
results in a not very efficient parser. While efficience is not a huge problem for us
at this point (and the generated parser is still <strong>way</strong> more efficient than the one
generated by ANTLR), it seems that the “not-quite-LRish” converted grammar triggers a
bug(?) in tree-sitter, causing a valid code to be not recognized. See <a href="#known-issues">Known Issues</a> section.</li>
  <li>The spec parser is not really intended to have any parse tree consumers, so the grammar
is structured in a way producing deeply nested trees even for simple syntactic constructions.
This makes the produced parse tree not very useful for editors, since there is too much
noise. Fortunately tree-sitter provide two ways to hide the intermediate nodes.
Unfortuntely I don’t see a way to deduce what to hide from the spec grammar automatically.
The current plan is to have a human maintained list of visible rules.</li>
  <li>Some advanced tree-sitter concepts, like node supertypes and node fields don’t have
counterparts in the spec grammar, so there is nothing to convert automatically, so if
we want to add those, we would have to also supply this information to the coverter as
an additional input.</li>
</ul>

<h1 id="evaluation">Evaluation</h1>

<p>As an evaluation, I’ve tried parsing all Dart files in the <a href="https://github.com/dart-lang/sdk">Dart SDK repo</a> (<a href="e9df8dceab89790ddc55c8d0ed388fcfe8fe879f">commit</a>).</p>

<p>SDK is good in the sense that there are lots of test files that specifically test various syntax pecularities.</p>

<h2 id="methodology">Methodology</h2>

<p><strong>NOTE</strong>: I only compare the binary <code class="language-plaintext highlighter-rouge">SUCCESS</code> vs <code class="language-plaintext highlighter-rouge">FAILED</code> results. That’s obviously not very precise: it can be the case that we parse some file incorrectly, but there is still no error. This won’t be detected.</p>

<h3 id="getting-results-for-the-new-parser">Getting results for the new parser</h3>

<p>I’ve found all Dart files using</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ag <span class="nt">-g</span> <span class="s1">'.*\.dart$'</span> dart-sdk-path
</code></pre></div></div>

<p>Results are in <a href="evaluation_results/sdk-sources.lst">file</a>.</p>

<p>Then I ran</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tree-sitter parse <span class="nt">-q</span> <span class="nt">-s</span> <span class="nt">-t</span> sdk-sources.lst
</code></pre></div></div>

<p>Output of this command can be found in <a href="evaluation_results/sdk-parse-stats.txt">file</a>.</p>

<h3 id="baseline-for-the-comparison">Baseline for the comparison</h3>

<p>It’s most natural to compare the new parser with the spec parser, that was used as a source.</p>

<p>Additionally I also test the new parser vs the actual Dart implementation, to be some absolute numbers.</p>

<h3 id="results">Results</h3>

<h4 id="the-new-parser-vs-the-spec-parser">The new parser vs the spec parser</h4>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Total number of files</td>
      <td>46007</td>
    </tr>
    <tr>
      <td>Number of cases that failed with the converted parser, but passed with the spec parser</td>
      <td>32</td>
    </tr>
    <tr>
      <td>Number of cases that passed with the converted parser, but failed with the spec parser</td>
      <td>570</td>
    </tr>
    <tr>
      <td>Total number of cases where the converted parser and the spec parser disagree</td>
      <td>602</td>
    </tr>
    <tr>
      <td>False negatives in the converted parser vs the spec parser</td>
      <td>0.070%</td>
    </tr>
    <tr>
      <td>False positives in the converted parser vs the spec parser</td>
      <td>1.239%</td>
    </tr>
    <tr>
      <td>Precision the converted parser vs the spec parser</td>
      <td>98.692%</td>
    </tr>
  </tbody>
</table>

<p>The overall precision of 98.69% is not super exciting, I’d hope to get much closer to 100% using the automatic conversion. But fortunately for the most applications of tree-sitter false positives don’t matter that much: it’s probably ok to parse more than the actual implementation, as long as correct code is parsed correctly. And if we only take false negatives into account, we get exciting 99.93% precision.</p>

<p>I’ve analyzed most of false negatives and found 2 issues, explaining them. See <a href="#known-issues">Known Issues</a>.</p>

<h4 id="the-new-parser-vs-the-actual-implementation">The new parser vs the actual implementation</h4>

<p><strong>NOTE</strong>: the spec parser used in the conversion <em>does</em> support <code class="language-plaintext highlighter-rouge">augment</code> keyword related syntax, but <em>doesn’t</em> support <code class="language-plaintext highlighter-rouge">macro</code>. But in the actual implementation, both are gated by the <code class="language-plaintext highlighter-rouge">macros</code> language feature, so either both are enabled, or both are disabled. So we could either increase the false negatives number by enabling the feature or increase the false positives number by keeping the feature disabled. I’ve opted into keeping it disabled, as I’m more interested in false negative cases.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Total number of cases</td>
      <td>46007</td>
    </tr>
    <tr>
      <td>Number of cases that failed with the converted parser, but passed with the reference parser</td>
      <td>231</td>
    </tr>
    <tr>
      <td>Number of cases that passed with the converted parser, but failed with the reference parser</td>
      <td>856</td>
    </tr>
    <tr>
      <td>Total number of cases where the converted parser and the reference parser disagree</td>
      <td>1087</td>
    </tr>
    <tr>
      <td>False negatives in the converted parser vs the reference parser</td>
      <td>0.502%</td>
    </tr>
    <tr>
      <td>False positives in the converted parser vs the reference parser</td>
      <td>1.861%</td>
    </tr>
    <tr>
      <td>Precision the converted parser vs the reference parser</td>
      <td>97.637%</td>
    </tr>
  </tbody>
</table>

<h1 id="known-issues">Known Issues</h1>

<h2 id="record-literals-vs-types-vs-patterns">Record literals vs types vs patterns</h2>

<p>There are a number of cases there record literals are not parsed correctly. This issue cause nearly half of false negative cases.</p>

<p>Examples:</p>

<ol>
  <li>Record literals in expression statements:
    <div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p><code class="language-plaintext highlighter-rouge">(x,y)</code> is parsed as a type here, so and indentifier is expected.</p>
  </li>
  <li>Record literals as a function argument:
    <div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="n">v</span> <span class="o">=</span> <span class="n">f</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">));</span>
</code></pre></div>    </div>
    <p>Here <code class="language-plaintext highlighter-rouge">(x,y)</code> is parsed as a record pattern, so the whole <code class="language-plaintext highlighter-rouge">f((x,y))</code> becomes an object pattern.</p>
  </li>
  <li>Record literals inside list literals:
    <div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="n">v</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)];</span>
</code></pre></div>    </div>
    <p>Here again <code class="language-plaintext highlighter-rouge">(x,y)</code> is parsed as a record pattern, making the whole thing list pattern.</p>
  </li>
</ol>

<p>The reason is highly overloaded syntax for records: <code class="language-plaintext highlighter-rouge">(x,y)</code> can be a record type, a record literal or a record patter.
Normally a GLR parser should resolve these conflicts, but apparently tree-sitter doesn’t. This looks to be
a bug in tree-sitter.</p>

<p>TODO: file bug, add link</p>

<h2 id="-inside-multi-line-comment"><code class="language-plaintext highlighter-rouge">//</code> inside multi-line comment</h2>

<p>Single line comment <code class="language-plaintext highlighter-rouge">//</code> inside multi-line comment can hide <code class="language-plaintext highlighter-rouge">/*</code> or <code class="language-plaintext highlighter-rouge">*/</code>. In Dart <code class="language-plaintext highlighter-rouge">//</code> has no
special meaning inside a multi-line comment, but because comments are implemented using the
tree-sitter’s <code class="language-plaintext highlighter-rouge">extras</code> feature and <code class="language-plaintext highlighter-rouge">extras</code> are recursive in tree-sitter, it actually allows single line comments to appear inside mult-line ones, so</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* // /*
*/</span> <span class="o">*/</span>
</code></pre></div></div>

<p>is not parsed correctly (<code class="language-plaintext highlighter-rouge">/*</code> on the first line gets swallowed by the single line comment rule).</p>

<p>This issue seems to be causing the other half of false negatives.</p>

<p>I’ve filed a <a href="https://github.com/tree-sitter/tree-sitter/issues/3225">FR</a> asking to make <code class="language-plaintext highlighter-rouge">extras</code> non-recursive.</p>

<h2 id="spurious-identifiers">Spurious identifiers</h2>

<p>Dart is pretty picky wrt which identifier is allowed in which place. For example, <code class="language-plaintext highlighter-rouge">as</code> is fine as a variable name, but not as a type name. This leads to somewhat complicated grammar rules for identifiers and certainly contributes to the <a href="#record-literals-vs-types-vs-patterns">issue with record literals</a>.</p>

<p>Technically in ANTLR this is achieved by defining an <code class="language-plaintext highlighter-rouge">IDENTIFIER</code> token to be very generic and relying on more specific keywords/reserved words/contextual keywords tokens to win over it. Such that a string <code class="language-plaintext highlighter-rouge">"as"</code> is always tokenized as <code class="language-plaintext highlighter-rouge">AS</code> and never as <code class="language-plaintext highlighter-rouge">IDENTIFIER</code>. On top of that, there are these complex identifier parser rules, that regulate which keyword tokens can appear where.</p>

<p>And the translator is currently translating this to tree-sitter syntax as is. The good thing is there are similar token priority rules in tree-sitter, so <code class="language-plaintext highlighter-rouge">AS</code> token also always wins against the <code class="language-plaintext highlighter-rouge">IDENTIFIER</code>. <strong>But</strong> tree-sitter does <em>context-sensitive</em> lexing (which is generally great, but bites us here), so in places where the grammar doesn’t expect <code class="language-plaintext highlighter-rouge">AS</code> token, it is not even matched, so <code class="language-plaintext highlighter-rouge">"as"</code> is tokenized as <code class="language-plaintext highlighter-rouge">IDENTIFIER</code>. This leads, for example, to things like</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">as</span> <span class="p">{}</span>
</code></pre></div></div>

<p>being parsed without any error.</p>

<p>This only causes false positives, so probably not a big deal. I even wonder if this should be a syntax error at all.</p>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/tree-sitter-dart/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Dart support for Tree Sitter</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Dart support for Tree Sitter</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/yanok"><svg class="svg-icon"><use xlink:href="/tree-sitter-dart/assets/minima-social-icons.svg#github"></use></svg> <span class="username">yanok</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>tree-sitter grammar for Dart, automatically converted from the spec parser.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
